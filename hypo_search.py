import numpy as np
from dl_model import dl_model
from operator import add
from copy import deepcopy
import pickle

# prevents underflow
func = np.log
inv_func = np.exp
min_cons = 2


def edit_distance(s1, s2, prob_ins, prob_del, prob_replacement):
    """
    Score for converting s1 into s2. Both s1 and s2 is a vector of phone IDs and not phones
    :param s1: string 1
    :param s2: string 2
    :param prob_ins: 38x1 array of insert probabilities for each phone
    :param prob_del: 38x1 array of delete probabilities for each phone
    :param prob_replacement: matrix of size 38x38
    :return:
    """
    m, n = len(s1), len(s2)
    prob_ins, prob_del, prob_replacement = np.array(func(prob_ins)), np.array(func(prob_del)), np.array(
        func(prob_replacement))

    dp = np.zeros((m + 1, n + 1))

    for i in range(m + 1):
        for j in range(n + 1):

            if i == 0:
                dp[i][j] = np.sum(prob_ins[s2[:j]])
            elif j == 0:
                dp[i][j] = np.sum(prob_del[s1[:i]])
            elif s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                remove, insert, replace = prob_del[s1[i - 1]], prob_ins[s2[j - 1]], prob_replacement[s1[i - 1]][
                    s2[j - 1]]
                dp[i][j] = max(dp[i - 1][j] + remove, dp[i][j - 1] + insert, dp[i - 1][j - 1] + replace)

    return dp


def generate_lattice(outputs, h_node, best_only, blank_token_id, collapse_type='max', print_final_lattice=True):
    """
    Generates lattice from outputs so that graph traversal can be used
    :param print_final_lattice: whether to pritn the final lattice
    :param best_only: if True, returns only the best phones at each timestep
    :param outputs: tsteps x num_phones matrix generated by LSTM
    :param h_node: threshold for probability
    :param collapse_type: if max, max_value of frame is considered in sequence; for sum, average is taken
    :return: [[phones above threshold and probabilities] after collapsing]
    """

    tsteps, num_phones = outputs.shape
    init_lattice = [[] for i in range(tsteps)]

    for i in range(tsteps):
        if best_only:
            phone_id = np.argmax(outputs[i])
            prob = outputs[i][phone_id]
            init_lattice[i].append((phone_id, prob))
        else:
            for j in range(num_phones):
                if outputs[i][j] >= h_node:
                    init_lattice[i].append((j, outputs[i][j]))

    # Remove blank tokens
    lattice = []
    for frame in init_lattice:
        cur = [x for x in frame if x[0] != blank_token_id]
        if len(cur) != 0:
            lattice.append(cur)

    # Collapse consecutive
    final_lattice = []

    previous_phones = [x[0] for x in lattice[0]]
    prev_probs = [x[1] for x in lattice[0]]
    num = 1

    for l in lattice[1:]:
        ids, vals = [x[0] for x in l], [x[1] for x in l]

        if ids == previous_phones:
            num += 1
            if collapse_type == 'sum':
                prev_probs = list(map(add, prev_probs, vals))
            else:
                prev_probs = [max(prev_probs[i], vals[i]) for i in range(len(prev_probs))]

        else:
            if collapse_type == 'sum' and num > min_cons:
                final_lattice.append(list(zip(previous_phones, [x / num for x in prev_probs])))
            elif collapse_type == 'max' and num > min_cons:
                final_lattice.append(list(zip(previous_phones, prev_probs)))

            previous_phones = ids
            prev_probs = vals
            num = 1
    # for the last sequence
    if collapse_type == 'sum' and num > min_cons:
        final_lattice.append(list(zip(previous_phones, [x / num for x in prev_probs])))
    elif collapse_type == 'max' and num > min_cons:
        final_lattice.append(list(zip(previous_phones, prev_probs)))

    if print_final_lattice:
        print('Final lattice:', final_lattice)

    return final_lattice


def traverse_best_lattice(lattice, target_string, insert_prob, del_prob, replace_prob):
    """
    Takes top-1 lattice and finds the best subsequence according to edit distance
    :param lattice: [[phones above threshold and probabilities] after collapsing]
    :param target_string: reference string to manipulate
    :param insert_prob: insertion probabilities
    :param del_prob: deletion probabilities
    :param replace_prob: substitution probabilities
    :return: best subsequence as ids of phones
    """
    m = len(lattice)
    n = len(target_string)
    prev_best = -np.inf
    best_subsequence = []

    for i in range(m):
        cur_string = [x[0][0] for x in lattice[i:]]
        edit_matrix = edit_distance(target_string, cur_string, insert_prob, del_prob, replace_prob)
        prob = 0
        for j in range(i, m):
            # log converts multiplication to addition
            prob += func(lattice[j][0][1])
            # n since first string is target string and we compare each subsequence with complete target string
            final_score = prob + edit_matrix[n][j - i + 1]
            # print('Final score (for i,j) = ({},{}) is {} + {} = {}'.format(i, j, prob, edit_matrix[n][j - i + 1],
            #                                                                final_score))
            if final_score > prev_best:
                # print("FOUND BEST")
                prev_best = final_score
                best_subsequence = cur_string[:j-i+1]

    return best_subsequence


def find_q_values(s1, s2, s2_node_prob, prob_ins, prob_del, prob_replacement):
    """
    Given best hypothesis and reference string, outputs the required Q scores for each phone
    :param s1: reference string
    :param s2: best hypotheses
    :param s2_node_prob: node probabilities obtained from LSTM
    :param prob_ins: score for inserting a phone
    :param prob_del: score for deleting a phone
    :param prob_replacement: confusion matrix
    :return: {phone1: [list of q vals], phone2: [list of qvals], ...}
    """
    m, n = len(s1), len(s2)
    dp = np.zeros((m + 1, n + 1))
    prob_ins, prob_del, prob_replacement, s2_node_prob = np.array(func(prob_ins)), np.array(func(prob_del)), np.array(
        func(prob_replacement)), func(np.array(s2_node_prob))
    # print('\nGround Truth:', s1, '\nBest Hypotheses:', s2, '\n')
    """
    op_dict is a dictionary of matching, inserting, deleting and replacing phones with the following convention:
    matching tuples - (index in reference, phone_id, lstm probability)
    insertion tuples - (index in hypotheses, phone_id, insertion prob of phone)
    deletion tuples - (index in reference, phone_id, deletion prob of phone)
    substitution tuples - (index in reference, old phone_id, index in hypotheses, new phone_id, replacement prob, new node prob)
    """
    op_dict = {}

    for i in range(m + 1):
        op_dict[i] = {}
        for j in range(n + 1):
            op_dict[i][j] = {'matches': [], 'insertions': [], 'deletions': [], 'substitutions': []}

    for i in range(m + 1):
        for j in range(n + 1):
            if i == 0:
                dp[i][j] = np.sum(prob_ins[s2[:j]])
                op_dict[i][j]['insertions'] = [(idx, s2[idx], prob_ins[s2[idx]], s2_node_prob[idx]) for idx in range(j)]
            elif j == 0:
                dp[i][j] = np.sum(prob_del[s1[:i]])
                op_dict[i][j]['deletions'] = [(idx, s1[idx], prob_del[s1[idx]]) for idx in range(i)]
            elif s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
                op_dict[i][j] = deepcopy(op_dict[i - 1][j - 1])
                op_dict[i][j]['matches'].append((i - 1, s1[i - 1], s2_node_prob[j - 1]))
            else:
                remove, insert, replace = prob_del[s1[i - 1]], prob_ins[s2[j - 1]], prob_replacement[s1[i - 1]][
                    s2[j - 1]]
                dp[i][j] = max(dp[i - 1][j] + remove, dp[i][j - 1] + insert, dp[i - 1][j - 1] + replace)

                if dp[i][j] == dp[i - 1][j] + remove:
                    op_dict[i][j] = deepcopy(op_dict[i - 1][j])
                    op_dict[i][j]['deletions'].append((i - 1, s1[i - 1], prob_del[s1[i - 1]]))
                elif dp[i][j] == dp[i][j - 1] + insert:
                    op_dict[i][j] = deepcopy(op_dict[i][j - 1])
                    op_dict[i][j]['insertions'].append((j - 1, s2[j - 1], prob_ins[s2[j - 1]], s2_node_prob[j-1]))
                else:
                    op_dict[i][j] = deepcopy(op_dict[i - 1][j - 1])
                    op_dict[i][j]['substitutions'].append((i - 1, s1[i - 1], j - 1, s2[j - 1],
                                                           prob_replacement[s1[i - 1]][s2[j - 1]], s2_node_prob[j - 1]))

    final_dict = {}
    op_dict = op_dict[m][n]
    # print(op_dict, '\n')

    for match in op_dict['matches']:
        ph_id, prob = match[1], match[2]
        if not ph_id in final_dict.keys():
            final_dict[ph_id] = []
        final_dict[ph_id].append(inv_func(prob))

    for deletion in op_dict['deletions']:
        ph_id, prob = deletion[1], deletion[2]
        if not ph_id in final_dict.keys():
            final_dict[ph_id] = []
        final_dict[ph_id].append(inv_func(prob))

    for substi in op_dict['substitutions']:
        ph_id, prob_substi, node_prob = substi[1], substi[4], substi[5]
        if not ph_id in final_dict.keys():
            final_dict[ph_id] = []
        final_dict[ph_id].append(inv_func(prob_substi + node_prob))

    for insertion in op_dict['insertions']:
        ph_id, prob, node_prob = insertion[1], insertion[2], insertion[3]
        if not ph_id in final_dict.keys():
            final_dict[ph_id] = []
        final_dict[ph_id].append(inv_func(prob + node_prob))

    # print(final_dict)
    return final_dict


def read_grtruth(filepath):
    # phones to be collapsed
    replacement = {'aa': ['ao'], 'ah': ['ax', 'ax-h'], 'er': ['axr'], 'hh': ['hv'], 'ih': ['ix'],
                   'l': ['el'], 'm': ['em'], 'n': ['en', 'nx'], 'ng': ['eng'], 'sh': ['zh'],
                   'pau': ['pcl', 'tcl', 'kcl', 'bcl', 'dcl', 'gcl', 'h#', 'epi', 'q'],
                   'uw': ['ux']}

    gr_phones = []
    with open(filepath, 'r') as f:
        a = f.readlines()
    for phenome in a:
        s_e_i = phenome[:-1].split(' ')  # start, end, phenome_name e.g. 0 5432 'aa'
        start, end, ph = int(s_e_i[0]), int(s_e_i[1]), s_e_i[2]

        # collapse into father phone
        for father, list_of_sons in replacement.items():
            if ph in list_of_sons:
                ph = father
                break
        gr_phones.append(ph)

    return gr_phones


if __name__ == '__main__':

    insert_prob, delete_prob, replace_prob = pickle.load(open('pickle/probs.pkl', 'rb'))
    a = dl_model('test_one')
    outputs, phone_to_id, id_to_phone = a.test_one(['trial/SI912.wav'])
    outputs = outputs[0]
    # print(outputs.shape, np.max(outputs, axis=1))
    final_lattice = generate_lattice(outputs, 0.2, False, a.model.blank_token_id)
    # exit(0)
    gr_phones = read_grtruth('trial/SI912.PHN')
    gr_phone_ids = np.array([phone_to_id[x][0] for x in gr_phones])

    res = traverse_best_lattice(final_lattice, gr_phone_ids, insert_prob, delete_prob, replace_prob)

    res_phones = [id_to_phone[x] for x in res]
    print('Ground truth:', gr_phones, '\n', 'Predicted:', res_phones)
    print(find_q_values(gr_phone_ids, res, [x[0][1] for x in final_lattice], insert_prob, delete_prob, replace_prob))
    # print(final_lattice, ([len(x) for x in final_lattice if len(x) != 1]))

    # phones = [[mapping[x[0]] for x in l] for l in final_lattice]
    # print(phones)
